////问题描述：
////假设要在足够多的会场里安排一批活动，并希望使用尽可能少的会场。设计一个有效的贪心算法进行安排。
////(这个问题实际上是著名的图着色问题。若将每一个活动作为图的一个顶点，不相容活动间用边相连。使相邻顶点着有不同颜色的最小着色数，相应于要找的最小会场数。)
////编程任务：
////对于给定的k 个待安排的活动，编程计算使用最少会场的时间表。
////数据输入：
////第一行有1 个正整数k，表示有k 个待安排的活动。接下来的k 行中，每行有2 个正整数，分别表示k 个待安排的活动开始时间和结束时间。时间以0 点开始的分钟计。
////结果输出：
////输出最少会场数。
//#include <iostream>
//#include <algorithm>
//#define MAX_NUM 10000
//
//using namespace std;
//
///*问题分析*/
//// 已经最优安排好了若干个场馆
//// 如果当前活动和所有场馆的最后一个活动都不相容，则安排一个新场馆
//// 否则安排在结束时间最晚的相容场馆里
//
//int main()
//{
//	int n;
//	int s[MAX_NUM], e[MAX_NUM];
//	bool arranged[MAX_NUM];
//
//	int rooms = 1;
//	cin >> n;
//
//	for (int i = 0; i < n; ++i)
//		cin >> s[i] >> e[i];
//
//	sort(s, s + n);
//	sort(e, e + n);
//
//	int arrange = 0;
//	for (int i = 1; i < n; ++i)
//	{
//		if (s[i] > e[arrange]) ++arrange;
//		else ++rooms;
//	}
//	
//	cout << rooms << endl;
//
//	return 0;
//}
