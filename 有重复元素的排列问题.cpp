////设R = { r1, r2 , …, rn }是要进行排列的n个元素。其中元素r1, r2, …, rn可能相同。试设计一个算法，列出R的所有不同排列。
//
//#include <iostream>
//using namespace std;
//
//void permute(int step, int n, int *num);
//// 算法核心思想：
//// 排列的做法是，共n个元素，轮流做第一个元素，之后剩余的n-1个递归排列
//// 不重复的排列实际上就是每一个元素重复1次的特殊重复排列
//// 重复排列在每一次选择第一个元素之后，将其数量-1，剩余的递归。（不重复的-1后变成0，也就是n-1个递归）
//// 证明：对于第一位，每种元素只选择一次（数量-1后不会继续选择它），则这一位不会出现重复的情况，依此类推每一位都不会有这种情况
//
//int in[26];
//char out[4];
//int main()
//{
//	int n;
//	int num = 0;
//	cin >> n;
//	char c;
//	for (int i = 0; i < n; ++i)
//	{
//		cin >> c;
//		++in[c - 'a' + 1]; // 相应的字母计数+1
//	}
//
//	permute(0, n, &num);
//	
//	cout << num;
//	return 0;
//}
//
//void permute(int step, int n, int* num)
//{
//	// 虽然递归出口写在最开始，但是写代码先写递归调用，然后再回过来写递归出口
//	if (step >= n) // step从0开始.此时一条out已经生成完毕
//	{
//		for (int i = 0; i < n; ++i)
//			cout << out[i];
//		cout << endl;
//		++ *num; // 增加计数
//	}
//
//	for (int i = 0; i < 26; ++i) //遍历每一个字母
//	{
//		if (in[i] > 0) // 这个字母还有剩余的
//		{
//			out[step] = i - 1 + 'a'; // 把它放到当前第一位
//			--in[i]; // 库存-1
//			permute(step + 1, n, num); // 递归剩下的
//			++in[i]; // 加回库存，因为一次排满后，下一次排列还要用他
//		}
//	}
//}